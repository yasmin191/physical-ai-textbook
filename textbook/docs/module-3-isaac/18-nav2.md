---
sidebar_position: 5
title: "Chapter 18: Nav2 Path Planning"
description: "Configure Nav2 for humanoid robot navigation and path planning"
---

# Chapter 18: Nav2 Path Planning

**Nav2** (Navigation2) is the ROS 2 navigation stack that enables autonomous robot navigation. For humanoid robots, Nav2 provides global and local path planning, obstacle avoidance, and behavior trees for complex navigation scenarios.

## Learning Objectives

By the end of this chapter, you will be able to:

- Understand the Nav2 architecture and components
- Configure costmaps for humanoid navigation
- Implement global and local planners
- Create behavior trees for navigation tasks
- Handle dynamic obstacles and social navigation

## 18.1 Nav2 Architecture

### Component Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                          Nav2 Stack                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐                     │
│  │  BT Navigator   │───►│ Behavior Trees  │                     │
│  └────────┬────────┘    └─────────────────┘                     │
│           │                                                     │
│     ┌─────┴─────┐                                               │
│     ▼           ▼                                               │
│  ┌─────────┐  ┌─────────┐                                       │
│  │ Global  │  │  Local  │                                       │
│  │ Planner │  │ Planner │                                       │
│  └────┬────┘  └────┬────┘                                       │
│       │            │                                            │
│       └──────┬─────┘                                            │
│              ▼                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    Costmap 2D                           │    │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │    │
│  │  │   Static     │  │  Obstacle    │  │  Inflation   │   │    │
│  │  │    Layer     │  │    Layer     │  │    Layer     │   │    │
│  │  └──────────────┘  └──────────────┘  └──────────────┘   │    │
│  └─────────────────────────────────────────────────────────┘    │
│                          │                                      │
│              ┌───────────┴───────────┐                          │
│              │    Controller         │                          │
│              │  (Velocity Commands)  │                          │
│              └───────────────────────┘                          │
└─────────────────────────────────────────────────────────────────┘
```

### Key Components

| Component | Purpose |
|-----------|---------|
| **BT Navigator** | Coordinates navigation behaviors |
| **Global Planner** | Finds path from start to goal |
| **Local Planner** | Follows path while avoiding obstacles |
| **Costmap** | Represents traversability |
| **Controller** | Converts plan to velocity commands |
| **Recovery** | Handles stuck situations |

## 18.2 Installation and Setup

### Installing Nav2

```bash
# Install Nav2 packages
sudo apt install ros-humble-navigation2
sudo apt install ros-humble-nav2-bringup

# Install behavior tree tools
sudo apt install ros-humble-behaviortree-cpp-v3
```

### Basic Launch Configuration

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    nav2_dir = get_package_share_directory('nav2_bringup')
    
    nav2_launch = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(nav2_dir, 'launch', 'navigation_launch.py')
        ),
        launch_arguments={
            'params_file': '/path/to/nav2_params.yaml',
            'use_sim_time': 'true',
        }.items()
    )
    
    return LaunchDescription([nav2_launch])
```

## 18.3 Costmap Configuration

### Costmap Structure

```yaml
# nav2_params.yaml
global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 1.0
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: base_link
      
      # Robot footprint (humanoid shape)
      footprint: "[[0.15, 0.1], [0.15, -0.1], [-0.1, -0.1], [-0.1, 0.1]]"
      
      resolution: 0.05
      track_unknown_space: true
      
      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]
      
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: true
        
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: true
        observation_sources: scan depth
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: true
          marking: true
          data_type: "LaserScan"
        depth:
          topic: /depth_camera/points
          max_obstacle_height: 2.0
          min_obstacle_height: 0.1
          clearing: true
          marking: true
          data_type: "PointCloud2"
          
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55  # Robot radius + safety margin

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 2.0
      global_frame: odom
      robot_base_frame: base_link
      rolling_window: true
      width: 3
      height: 3
      resolution: 0.05
      
      plugins: ["voxel_layer", "inflation_layer"]
      
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: true
        publish_voxel_map: true
        origin_z: 0.0
        z_resolution: 0.05
        z_voxels: 16
        max_obstacle_height: 2.0
        mark_threshold: 0
        observation_sources: depth
        depth:
          topic: /depth_camera/points
          max_obstacle_height: 2.0
          min_obstacle_height: 0.1
          clearing: true
          marking: true
          data_type: "PointCloud2"
          
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55
```

### Humanoid-Specific Costmap Considerations

```yaml
# Consider robot height for obstacles
global_costmap:
  global_costmap:
    ros__parameters:
      # 3D voxel layer for tall robot
      plugins: ["static_layer", "voxel_layer", "inflation_layer"]
      
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: true
        origin_z: 0.0
        z_resolution: 0.1
        z_voxels: 20  # Cover 2m height
        unknown_threshold: 15
        mark_threshold: 0
        
        # Consider obstacles at head height
        max_obstacle_height: 2.0
        min_obstacle_height: 0.0  # Include ground obstacles
```

## 18.4 Global Planners

### NavFn Planner (Dijkstra/A*)

```yaml
planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    planner_plugins: ["GridBased"]
    
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      tolerance: 0.5
      use_astar: true
      allow_unknown: true
```

### Smac Planner (State Lattice)

Better for non-holonomic robots:

```yaml
planner_server:
  ros__parameters:
    planner_plugins: ["SmacPlanner"]
    
    SmacPlanner:
      plugin: "nav2_smac_planner/SmacPlannerHybrid"
      tolerance: 0.25
      downsample_costmap: false
      downsampling_factor: 1
      
      # Motion primitives for humanoid
      minimum_turning_radius: 0.2
      max_on_approach_iterations: 1000
      max_iterations: 1000000
      
      # Smooth path
      smoother:
        max_iterations: 1000
        w_smooth: 0.3
        w_data: 0.2
```

### Theta* Planner (Any-Angle)

```yaml
planner_server:
  ros__parameters:
    planner_plugins: ["ThetaStar"]
    
    ThetaStar:
      plugin: "nav2_theta_star_planner/ThetaStarPlanner"
      how_many_corners: 8
      w_euc_cost: 1.0
      w_traversal_cost: 2.0
```

## 18.5 Local Planners (Controllers)

### DWB Controller

Dynamic Window approach with customizable critics:

```yaml
controller_server:
  ros__parameters:
    controller_frequency: 20.0
    controller_plugins: ["FollowPath"]
    
    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      
      # Robot limits (humanoid walking)
      min_vel_x: 0.0
      max_vel_x: 0.5  # 0.5 m/s walking speed
      max_vel_theta: 1.0  # rad/s
      min_vel_theta: -1.0
      
      acc_lim_x: 0.3
      acc_lim_theta: 1.0
      decel_lim_x: -0.3
      
      # Trajectory generation
      vx_samples: 20
      vy_samples: 0  # No lateral motion
      vtheta_samples: 20
      sim_time: 1.5
      
      # Critics
      critics: ["RotateToGoal", "Oscillation", "BaseObstacle", "GoalAlign", "PathAlign", "PathDist", "GoalDist"]
      
      BaseObstacle.scale: 0.02
      PathAlign.scale: 32.0
      PathAlign.forward_point_distance: 0.1
      GoalAlign.scale: 24.0
      GoalAlign.forward_point_distance: 0.1
      PathDist.scale: 32.0
      GoalDist.scale: 24.0
      RotateToGoal.scale: 32.0
      RotateToGoal.slowing_factor: 5.0
```

### Regulated Pure Pursuit

Smoother paths for bipedal locomotion:

```yaml
controller_server:
  ros__parameters:
    controller_plugins: ["FollowPath"]
    
    FollowPath:
      plugin: "nav2_regulated_pure_pursuit_controller::RegulatedPurePursuitController"
      
      # Lookahead
      desired_linear_vel: 0.4
      lookahead_dist: 0.6
      min_lookahead_dist: 0.3
      max_lookahead_dist: 0.9
      lookahead_time: 1.5
      
      # Speed regulation
      use_velocity_scaled_lookahead_dist: true
      min_approach_linear_velocity: 0.05
      approach_velocity_scaling_dist: 0.6
      
      # Rotation
      use_rotate_to_heading: true
      rotate_to_heading_angular_vel: 0.5
      rotate_to_heading_min_angle: 0.785  # 45 degrees
      
      # Collision checking
      use_collision_detection: true
      max_allowed_time_to_collision_up_to_carrot: 1.0
```

### MPPI Controller (Model Predictive Path Integral)

Advanced controller for complex maneuvers:

```yaml
controller_server:
  ros__parameters:
    controller_plugins: ["FollowPath"]
    
    FollowPath:
      plugin: "nav2_mppi_controller::MPPIController"
      
      # Model
      motion_model: "DiffDrive"
      
      # MPPI parameters
      time_steps: 56
      model_dt: 0.05
      batch_size: 2000
      vx_std: 0.2
      vy_std: 0.0
      wz_std: 0.4
      vx_max: 0.5
      vy_max: 0.0
      wz_max: 1.0
      
      # Iteration
      iteration_count: 1
      temperature: 0.3
      gamma: 0.015
      
      # Critics
      critics: ["ConstraintCritic", "ObstaclesCritic", "GoalCritic", "GoalAngleCritic", "PathFollowCritic", "PathAngleCritic", "PreferForwardCritic"]
      
      ObstaclesCritic:
        enabled: true
        cost_weight: 1.0
        inflation_radius: 0.3
        
      GoalCritic:
        enabled: true
        cost_weight: 5.0
        
      PathFollowCritic:
        enabled: true
        cost_weight: 5.0
```

## 18.6 Behavior Trees

### Navigation Behavior Tree

```xml
<!-- navigate_w_replanning.xml -->
<root main_tree_to_execute="MainTree">
  <BehaviorTree ID="MainTree">
    <RecoveryNode number_of_retries="6" name="NavigateRecovery">
      <PipelineSequence name="NavigateWithReplanning">
        
        <!-- Compute path to goal -->
        <RateController hz="1.0">
          <RecoveryNode number_of_retries="1">
            <ComputePathToPose goal="{goal}" path="{path}" planner_id="GridBased"/>
            <ClearEntireCostmap name="ClearGlobalCostmap" service_name="global_costmap/clear_entirely_global_costmap"/>
          </RecoveryNode>
        </RateController>
        
        <!-- Follow the path -->
        <RecoveryNode number_of_retries="1">
          <FollowPath path="{path}" controller_id="FollowPath"/>
          <ClearEntireCostmap name="ClearLocalCostmap" service_name="local_costmap/clear_entirely_local_costmap"/>
        </RecoveryNode>
        
      </PipelineSequence>
      
      <!-- Recovery behaviors -->
      <SequenceStar name="RecoveryActions">
        <ClearEntireCostmap name="ClearGlobalCostmap" service_name="global_costmap/clear_entirely_global_costmap"/>
        <ClearEntireCostmap name="ClearLocalCostmap" service_name="local_costmap/clear_entirely_local_costmap"/>
        <Spin spin_dist="1.57"/>
        <Wait wait_duration="5"/>
        <BackUp backup_dist="0.3" backup_speed="0.05"/>
      </SequenceStar>
      
    </RecoveryNode>
  </BehaviorTree>
</root>
```

### Custom Behavior Tree Nodes

```cpp
// custom_bt_nodes.cpp
#include "behaviortree_cpp_v3/behavior_tree.h"
#include "nav2_behavior_tree/bt_action_node.hpp"

class CheckBatteryCondition : public BT::ConditionNode
{
public:
  CheckBatteryCondition(const std::string& name, const BT::NodeConfiguration& config)
    : BT::ConditionNode(name, config) {}

  static BT::PortsList providedPorts()
  {
    return { BT::InputPort<float>("min_battery") };
  }

  BT::NodeStatus tick() override
  {
    float min_battery;
    getInput("min_battery", min_battery);
    
    // Check current battery level
    float current_battery = getBatteryLevel();
    
    if (current_battery > min_battery) {
      return BT::NodeStatus::SUCCESS;
    }
    return BT::NodeStatus::FAILURE;
  }
};

// Register the node
BT_REGISTER_NODES(factory)
{
  factory.registerNodeType<CheckBatteryCondition>("CheckBattery");
}
```

### Behavior Tree for Humanoid Tasks

```xml
<!-- humanoid_navigation.xml -->
<root main_tree_to_execute="HumanoidNav">
  <BehaviorTree ID="HumanoidNav">
    <Sequence>
      <!-- Check if standing -->
      <Condition ID="IsStanding"/>
      
      <!-- Stand up if fallen -->
      <Fallback>
        <Condition ID="IsStanding"/>
        <Action ID="StandUp"/>
      </Fallback>
      
      <!-- Navigate with social awareness -->
      <RecoveryNode number_of_retries="3">
        <Sequence>
          <!-- Plan path avoiding humans -->
          <Action ID="ComputeSocialPath" goal="{goal}" path="{path}"/>
          
          <!-- Follow path with walking gait -->
          <Action ID="WalkPath" path="{path}"/>
        </Sequence>
        
        <!-- Recovery: stop and wait -->
        <Sequence>
          <Action ID="StopWalking"/>
          <Action ID="Wait" duration="2.0"/>
        </Sequence>
      </RecoveryNode>
      
    </Sequence>
  </BehaviorTree>
</root>
```

## 18.7 Dynamic Obstacle Avoidance

### Velocity Obstacles

```python
import numpy as np

class VelocityObstacleAvoidance:
    def __init__(self, robot_radius, time_horizon=2.0):
        self.robot_radius = robot_radius
        self.time_horizon = time_horizon
    
    def compute_safe_velocity(self, robot_pos, robot_vel, obstacles):
        """Compute velocity that avoids collisions."""
        # Sample velocities
        velocities = self.sample_velocities()
        
        safe_velocities = []
        for v in velocities:
            if self.is_velocity_safe(robot_pos, v, obstacles):
                safe_velocities.append(v)
        
        # Return velocity closest to desired
        if len(safe_velocities) == 0:
            return np.array([0, 0])  # Stop if no safe velocity
        
        # Choose velocity closest to current
        distances = [np.linalg.norm(v - robot_vel) for v in safe_velocities]
        return safe_velocities[np.argmin(distances)]
    
    def is_velocity_safe(self, robot_pos, velocity, obstacles):
        """Check if velocity leads to collision."""
        for obs in obstacles:
            obs_pos = obs['position']
            obs_vel = obs['velocity']
            obs_radius = obs['radius']
            
            # Relative position and velocity
            rel_pos = obs_pos - robot_pos
            rel_vel = velocity - obs_vel
            
            # Combined radius
            combined_radius = self.robot_radius + obs_radius
            
            # Check if collision within time horizon
            a = np.dot(rel_vel, rel_vel)
            b = 2 * np.dot(rel_pos, rel_vel)
            c = np.dot(rel_pos, rel_pos) - combined_radius**2
            
            discriminant = b**2 - 4*a*c
            
            if discriminant >= 0 and a > 0:
                t1 = (-b - np.sqrt(discriminant)) / (2*a)
                if 0 < t1 < self.time_horizon:
                    return False
        
        return True
```

### Human-Aware Navigation

```yaml
# Social costmap layer
local_costmap:
  local_costmap:
    ros__parameters:
      plugins: ["voxel_layer", "social_layer", "inflation_layer"]
      
      social_layer:
        plugin: "social_navigation_layers/ProxemicLayer"
        enabled: true
        cutoff: 5.0
        amplitude: 1.0
        covariance_front: 0.25
        covariance_side: 0.05
        covariance_back: 0.15
        people_topic: /people
```

## 18.8 Recovery Behaviors

### Humanoid-Specific Recovery

```yaml
recovery_server:
  ros__parameters:
    recovery_plugins: ["spin", "backup", "wait", "stand_up"]
    
    spin:
      plugin: "nav2_recoveries/Spin"
      
    backup:
      plugin: "nav2_recoveries/BackUp"
      
    wait:
      plugin: "nav2_recoveries/Wait"
      
    # Custom recovery for humanoid
    stand_up:
      plugin: "humanoid_nav/StandUpRecovery"
```

### Custom Recovery Plugin

```cpp
// stand_up_recovery.cpp
#include "nav2_core/recovery.hpp"

class StandUpRecovery : public nav2_core::Recovery
{
public:
  void onConfigure() override
  {
    stand_up_client_ = node_->create_client<humanoid_msgs::srv::StandUp>("/stand_up");
  }

  Status onRun(const std::shared_ptr<const Action::Goal> goal) override
  {
    // Check if robot has fallen
    if (!hasFallen()) {
      return Status::SUCCEEDED;
    }

    // Request stand up
    auto request = std::make_shared<humanoid_msgs::srv::StandUp::Request>();
    auto future = stand_up_client_->async_send_request(request);
    
    if (future.wait_for(std::chrono::seconds(10)) == std::future_status::ready) {
      if (future.get()->success) {
        return Status::SUCCEEDED;
      }
    }
    
    return Status::FAILED;
  }

private:
  rclcpp::Client<humanoid_msgs::srv::StandUp>::SharedPtr stand_up_client_;
};
```

## 18.9 Complete Navigation Example

### Launch File

```python
from launch import LaunchDescription
from launch_ros.actions import Node
from launch.actions import IncludeLaunchDescription
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    pkg_dir = get_package_share_directory('humanoid_navigation')
    
    # Localization (AMCL or Visual SLAM)
    localization = Node(
        package='nav2_amcl',
        executable='amcl',
        name='amcl',
        parameters=[os.path.join(pkg_dir, 'config', 'amcl.yaml')],
    )
    
    # Map server
    map_server = Node(
        package='nav2_map_server',
        executable='map_server',
        name='map_server',
        parameters=[{'yaml_filename': '/path/to/map.yaml'}],
    )
    
    # Navigation
    nav2 = IncludeLaunchDescription(
        os.path.join(
            get_package_share_directory('nav2_bringup'),
            'launch', 'navigation_launch.py'
        ),
        launch_arguments={
            'params_file': os.path.join(pkg_dir, 'config', 'nav2_params.yaml'),
            'use_sim_time': 'true',
        }.items()
    )
    
    # Lifecycle manager
    lifecycle_manager = Node(
        package='nav2_lifecycle_manager',
        executable='lifecycle_manager',
        name='lifecycle_manager_navigation',
        parameters=[{
            'autostart': True,
            'node_names': [
                'map_server',
                'amcl',
                'planner_server',
                'controller_server',
                'recoveries_server',
                'bt_navigator',
            ]
        }],
    )
    
    return LaunchDescription([
        map_server,
        localization,
        nav2,
        lifecycle_manager,
    ])
```

## 18.10 Summary

In this chapter, you learned:

- **Nav2 architecture**: Components and data flow
- **Costmaps**: Configuration for humanoid robots
- **Global planners**: NavFn, Smac, Theta*
- **Local planners**: DWB, Regulated Pure Pursuit, MPPI
- **Behavior trees**: Navigation task orchestration
- **Dynamic obstacles**: Velocity obstacles and social navigation
- **Recovery behaviors**: Handling stuck situations

Nav2 provides robust navigation for humanoid robots. In the next chapter, we'll explore reinforcement learning for locomotion control.

## Review Questions

1. What is the difference between global and local costmaps?
2. Why is inflation radius important for humanoid navigation?
3. How do behavior trees coordinate navigation tasks?
4. What is social navigation and why is it important?
5. When are recovery behaviors triggered?

## Hands-On Exercise

1. Configure Nav2 for your humanoid robot
2. Create costmaps with appropriate resolution and layers
3. Compare different global planners (NavFn vs Smac)
4. Implement a custom behavior tree for patrol navigation
5. Add social navigation to avoid people
6. Create a custom recovery behavior for your robot
